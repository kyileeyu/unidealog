---
emoji: '🏗️'
title: 'Getting Started with Feature-Sliced Design'
date: '2024-01-15'
author: 'Your Name'
tags: ['architecture', 'fsd', 'frontend']
categories: ['development']
description: 'Learn how to organize your code using the Feature-Sliced Design architecture.'
---

# Feature-Sliced Design으로 시작하기 🏗️

**Feature-Sliced Design (FSD)**는 프론트엔드 애플리케이션을 위한 현대적인 아키텍처 방법론입니다. 이 글에서는 FSD의 핵심 개념과 실제 적용 방법을 알아보겠습니다.

## 🤔 FSD가 무엇인가요?

Feature-Sliced Design은 다음과 같은 문제들을 해결하기 위해 만들어졌습니다:

- **코드 구조의 일관성 부족**
- **컴포넌트 간 의존성 관리 어려움**
- **재사용성 부족**
- **팀 협업의 복잡성**

## 📊 FSD의 계층 구조

FSD는 6개의 표준화된 계층으로 구성됩니다:

### 1. 🔧 Shared Layer
```typescript
// shared/ui/button/Button.tsx
export const Button = ({ children, variant = "default" }) => {
  return (
    <button className={`btn btn-${variant}`}>
      {children}
    </button>
  );
};
```

**목적**: 재사용 가능한 공통 자원
- UI 컴포넌트 (Button, Input, Modal)
- 유틸리티 함수
- 상수 및 설정

### 2. 🎯 Entities Layer
```typescript
// entities/post/model/types.ts
export interface Post {
  id: string;
  title: string;
  content: string;
  author: string;
  createdAt: Date;
}

// entities/post/api/getPosts.ts
export const getPosts = async (): Promise<Post[]> => {
  // API 호출 로직
};
```

**목적**: 비즈니스 엔티티 정의
- 데이터 모델
- API 메서드
- 비즈니스 로직

### 3. ⚡ Features Layer
```typescript
// features/post-search/ui/SearchInput.tsx
export const SearchInput = () => {
  const [query, setQuery] = useState('');
  
  return (
    <Input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="검색어를 입력하세요..."
    />
  );
};
```

**목적**: 사용자 상호작용 기능
- 검색 기능
- 필터링
- 인증 로직

### 4. 🧩 Widgets Layer
```typescript
// widgets/post-card/ui/PostCard.tsx
import { Post } from '@/entities/post';
import { LikeButton } from '@/features/like-post';
import { ShareButton } from '@/features/share-post';

export const PostCard = ({ post }: { post: Post }) => {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{post.title}</CardTitle>
      </CardHeader>
      <CardContent>
        <p>{post.excerpt}</p>
      </CardContent>
      <CardFooter>
        <LikeButton postId={post.id} />
        <ShareButton post={post} />
      </CardFooter>
    </Card>
  );
};
```

**목적**: 여러 entities와 features를 조합한 복합 UI
- 포스트 카드
- 네비게이션 바
- 사이드바

### 5. 📄 Pages Layer
```typescript
// pages/post-detail/ui/PostDetailPage.tsx
import { PostContent } from '@/widgets/post-content';
import { CommentSection } from '@/widgets/comment-section';
import { PostNavigation } from '@/features/post-navigation';

export const PostDetailPage = ({ post }: { post: Post }) => {
  return (
    <main>
      <PostContent post={post} />
      <PostNavigation currentPost={post} />
      <CommentSection postId={post.id} />
    </main>
  );
};
```

**목적**: 완전한 페이지 구성
- 라우팅되는 페이지들
- 여러 위젯들의 조합

### 6. 📱 App Layer
```typescript
// app/layout.tsx
import { Header } from '@/widgets/header';
import { Footer } from '@/widgets/footer';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Header />
        {children}
        <Footer />
      </body>
    </html>
  );
}
```

**목적**: 애플리케이션 초기화 및 전역 설정

## 🎯 FSD의 핵심 원칙

### 1. 단방향 의존성
상위 계층은 하위 계층만 참조할 수 있습니다:
```
Pages → Widgets → Features → Entities → Shared
```

### 2. 격리와 캡슐화
각 모듈은 독립적이며 명확한 인터페이스를 제공합니다:

```typescript
// ✅ 좋은 예
import { Button } from '@/shared/ui/button';
import { useAuth } from '@/entities/user';

// ❌ 나쁜 예 - 계층을 건너뛰는 의존성
import { AuthButton } from '@/widgets/auth/ui/auth-button';
```

### 3. 명시적 API
각 계층은 명확한 public API를 제공합니다:

```typescript
// entities/post/index.ts
export { Post, type PostType } from './model';
export { getPosts, createPost } from './api';
export { formatPostDate } from './lib';
```

## 🚀 실제 프로젝트에 적용하기

### 1. 프로젝트 구조 설정
```bash
src/
├── shared/
│   ├── ui/
│   ├── lib/
│   └── config/
├── entities/
│   ├── post/
│   ├── user/
│   └── category/
├── features/
│   ├── post-search/
│   ├── theme-switch/
│   └── auth/
├── widgets/
│   ├── header/
│   ├── post-card/
│   └── sidebar/
└── pages/
    ├── home/
    ├── post-detail/
    └── profile/
```

### 2. 팀 워크플로우
1. **Shared 계층부터 시작**: 기본 UI 컴포넌트 구축
2. **Entities 정의**: 비즈니스 로직과 데이터 모델 설계
3. **Features 구현**: 사용자 기능 개발
4. **Widgets 조합**: 복합 UI 컴포넌트 구성
5. **Pages 완성**: 최종 페이지 구성

## 💡 FSD의 장점

### ✅ 확장성
- 새로운 기능 추가가 쉬움
- 기존 코드에 영향 최소화

### ✅ 유지보수성
- 명확한 구조로 버그 추적 용이
- 리팩토링 시 영향 범위 예측 가능

### ✅ 재사용성
- 컴포넌트와 로직의 높은 재사용성
- 다른 프로젝트로의 이식 용이

### ✅ 팀 협업
- 표준화된 구조로 팀원 간 이해도 향상
- 코드 리뷰 효율성 증대

## 🎓 마무리

Feature-Sliced Design은 단순한 폴더 구조가 아닌, **사고의 프레임워크**입니다. 처음에는 복잡해 보일 수 있지만, 일관된 적용을 통해 더 나은 코드베이스를 구축할 수 있습니다.

---

> **다음 글에서는**: FSD와 Next.js App Router를 함께 사용하는 실전 팁을 다뤄보겠습니다! 🚀
